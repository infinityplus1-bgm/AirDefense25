# Package: air_defense_sim

## Overview

This package provides a **simulation environment** for the AirDefense2025 system using **Gazebo**. It aims to replicate the behavior of the `main` package and the competition environment without requiring physical hardware.

This is crucial for:
* Testing perception, control, and strategy algorithms safely.
* Development when hardware is unavailable.
* Reproducible testing scenarios.

It replaces hardware interfaces found in the `main` package with Gazebo plugins for sensors (cameras, LIDAR) and actuators (joints controlled via `ros2_control`).

## Dependencies

* ROS2 Humble
* **Gazebo:** The simulation engine. Requires `ros-humble-gazebo-*` packages.
    * Run `sudo apt update && sudo apt install ros-humble-gazebo-ros-pkgs` if not already installed.
* `ros2_control` and `ros2_controllers` (likely needed for simulating joint control).
* Gazebo plugins (standard or custom).
* Robot Description (URDF/SDF) compatible with Gazebo.

## Key Components

* **Gazebo World Files (`worlds/`):** Define the simulation environment (e.g., `competition_arena.world`). This includes terrain, lighting, static objects, and potentially target spawning logic.
* **Robot Model (`urdf/` or `sdf/`):** The robot's description file (e.g., `air_defense_robot.urdf.xacro`) including links, joints, inertia, visuals, collision models, and **Gazebo tags** for sensors and `ros2_control`.
* **Gazebo Plugins:**
    * **Sensor Plugins:** Simulate cameras (`libgazebo_ros_camera.so`), LIDAR (`libgazebo_ros_ray_sensor.so`), IMUs, etc., publishing data on ROS topics mimicking real sensors.
    * **`ros2_control` Plugin:** (`libgazebo_ros2_control.so`) Interfaces Gazebo joints with the `ros2_control` framework, allowing nodes like `actuator_controller` (potentially reused from `main` or a simulated version) to control simulated joints.
    * Custom plugins if needed (e.g., for target spawning/movement).
* **Simulation-Specific Nodes:** Potentially nodes for spawning the robot model into Gazebo, managing simulation state, or providing ground truth information for debugging.

## Launch Files

Launch files orchestrate starting the simulation environment.

* **`simulation.launch.py` (Example):** The main launch file to start a simulation run. It typically performs these actions:
    1.  Starts the Gazebo server (`gzserver`) and client (`gzclient`).
    2.  Loads the specified world file.
    3.  Loads the robot description URDF/SDF.
    4.  Starts `robot_state_publisher` to publish TF transforms based on joint states.
    5.  Spawns the robot model into the Gazebo world.
    6.  Starts `ros2_control` controllers (e.g., `joint_state_broadcaster`, `joint_trajectory_controller`).
    7.  Launches the core logic nodes (potentially reusing nodes from the `main` package like `target_detector`, `mission_planner`, `actuator_controller` if they are written to be hardware-agnostic).

    ```bash
    # Example Usage (replace with actual launch file name)
    ros2 launch air_defense_sim simulation.launch.py world:=competition_arena.world
    ```

*(Add details about other relevant launch files, e.g., for testing specific simulation components)*

## Differences from `main` Package

* Uses Gazebo plugins instead of real hardware drivers.
* Sensor data is generated by Gazebo, not physical sensors.
* Actuator commands move simulated joints, not physical hardware.
* May include extra nodes/tools for simulation management (spawning, state control).
* Requires Gazebo and related ROS packages to be installed.